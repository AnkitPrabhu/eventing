diff --git a/src/mapreduce/jsfunctions/CMakeLists.txt b/src/mapreduce/jsfunctions/CMakeLists.txt
index f3c28f0..ff5923f 100644
--- a/src/mapreduce/jsfunctions/CMakeLists.txt
+++ b/src/mapreduce/jsfunctions/CMakeLists.txt
@@ -2,7 +2,6 @@ SET(ESPRIMA_FILE ${CMAKE_CURRENT_SOURCE_DIR}/esprima.js)
 SET(UNUSED_CONTEXT_FILE ${CMAKE_CURRENT_SOURCE_DIR}/unused/context.js)
 SET(UNUSED_INDEX_FILE ${CMAKE_CURRENT_SOURCE_DIR}/unused/index.js)
 SET(IS_DOC_USED_FILE ${CMAKE_CURRENT_SOURCE_DIR}/is_doc_used.js)
-SET(BUILTIN_JS_FILE ${CMAKE_CURRENT_SOURCE_DIR}/builtin.js)
 
 TRY_RUN(EMBED_DATA_EXITCODE EMBED_DATA_COMPILED
     ${CMAKE_CURRENT_BINARY_DIR}
diff --git a/src/mapreduce/mapreduce.cc b/src/mapreduce/mapreduce.cc
index 363ac00..eb48894 100644
--- a/src/mapreduce/mapreduce.cc
+++ b/src/mapreduce/mapreduce.cc
@@ -26,7 +26,7 @@
 #include <vector>
 #include "mapreduce.h"
 // This is libv8_libplatform library which handles garbage collection for v8
-#include <include/libplatform/libplatform.h>
+#include <libplatform/libplatform.h>
 // Esprima unused and builtin JavaScript contents in raw string format
 #include "jsfunctions/jsfunctions_data.h"
 
@@ -36,6 +36,66 @@
 
 using namespace v8;
 
+static const char *SUM_FUNCTION_STRING =
+    "(function(values) {"
+    "    var sum = 0;"
+    "    for (var i = 0; i < values.length; ++i) {"
+    "        sum += values[i];"
+    "    }"
+    "    return sum;"
+    "})";
+
+static const char *DATE_FUNCTION_STRING =
+    // I wish it was on the prototype, but that will require bigger
+    // C changes as adding to the date prototype should be done on
+    // process launch. The code you see here may be faster, but it
+    // is less JavaScripty.
+    // "Date.prototype.toArray = (function() {"
+    "(function(date) {"
+    "    date = date.getUTCDate ? date : new Date(date);"
+    "    return isFinite(date.valueOf()) ?"
+    "      [date.getUTCFullYear(),"
+    "      (date.getUTCMonth() + 1),"
+    "       date.getUTCDate(),"
+    "       date.getUTCHours(),"
+    "       date.getUTCMinutes(),"
+    "       date.getUTCSeconds()] : null;"
+    "})";
+
+static const char *BASE64_FUNCTION_STRING =
+    "(function(b64) {"
+    "    var i, j, l, tmp, scratch, arr = [];"
+    "    var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';"
+    "    if (typeof b64 !== 'string') {"
+    "        throw 'Input is not a string';"
+    "    }"
+    "    if (b64.length % 4 > 0) {"
+    "        throw 'Invalid base64 source.';"
+    "    }"
+    "    scratch = b64.indexOf('=');"
+    "    scratch = scratch > 0 ? b64.length - scratch : 0;"
+    "    l = scratch > 0 ? b64.length - 4 : b64.length;"
+    "    for (i = 0, j = 0; i < l; i += 4, j += 3) {"
+    "        tmp = (lookup.indexOf(b64[i]) << 18) | (lookup.indexOf(b64[i + 1]) << 12);"
+    "        tmp |= (lookup.indexOf(b64[i + 2]) << 6) | lookup.indexOf(b64[i + 3]);"
+    "        arr.push((tmp & 0xFF0000) >> 16);"
+    "        arr.push((tmp & 0xFF00) >> 8);"
+    "        arr.push(tmp & 0xFF);"
+    "    }"
+    "    if (scratch === 2) {"
+    "        tmp = (lookup.indexOf(b64[i]) << 2) | (lookup.indexOf(b64[i + 1]) >> 4);"
+    "        arr.push(tmp & 0xFF);"
+    "    } else if (scratch === 1) {"
+    "        tmp = (lookup.indexOf(b64[i]) << 10) | (lookup.indexOf(b64[i + 1]) << 4);"
+    "        tmp |= (lookup.indexOf(b64[i + 2]) >> 2);"
+    "        arr.push((tmp >> 8) & 0xFF);"
+    "        arr.push(tmp & 0xFF);"
+    "    }"
+    "    return arr;"
+    "})";
+
+
+
 typedef struct {
     Persistent<Object>    jsonObject;
     Persistent<Function>  jsonParseFun;
@@ -67,14 +127,12 @@ static std::string exceptionString(const TryCatch &tryCatch);
 static void freeLogResults(map_reduce_ctx_t *ctx);
 
 static Platform *v8platform;
-static StartupData startupData;
 void initV8()
 {
     V8::InitializeICU();
     v8platform = platform::CreateDefaultPlatform();
     V8::InitializePlatform(v8platform);
     V8::Initialize();
-    startupData = V8::CreateSnapshotDataBlob((char *)jsFunction_src);
 }
 
 void deinitV8()
@@ -82,7 +140,6 @@ void deinitV8()
     V8::Dispose();
     V8::ShutdownPlatform();
     delete v8platform;
-    delete[] startupData.data;
 }
 
 void setOptimizeDocLoadFlag(const char *flag)
@@ -134,10 +191,9 @@ void doInitContext(map_reduce_ctx_t *ctx, const function_sources_list_t &funs,
                    const view_index_type_t viewType)
 {
     ctx->viewType = viewType;
-    ctx->bufAllocator = new ArrayBufferAllocator();
     Isolate::CreateParams createParams;
-    createParams.snapshot_blob = &startupData;
-    createParams.array_buffer_allocator = ctx->bufAllocator;
+    createParams.array_buffer_allocator =
+      ArrayBuffer::Allocator::NewDefaultAllocator();
     ctx->isolate = Isolate::New(createParams);
     ctx->logResults = NULL;
     Locker locker(ctx->isolate);
@@ -438,7 +494,6 @@ void destroyContext(map_reduce_ctx_t *ctx)
     }
 
     ctx->isolate->Dispose();
-    delete ctx->bufAllocator;
     ctx->~map_reduce_ctx_t();
 }
 
@@ -457,6 +512,20 @@ static Local<Context> createJsContext(map_reduce_ctx_t *ctx)
     Handle<Context> context = Context::New(ctx->isolate, NULL, global);
     Context::Scope context_scope(context);
 
+    Handle<Function> sumFun = compileFunction(SUM_FUNCTION_STRING);
+    context->Global()->Set(createUtf8String(ctx->isolate, "sum"), sumFun);
+
+    Handle<Function> decodeBase64Fun =
+        compileFunction(BASE64_FUNCTION_STRING);
+    context->Global()->Set(createUtf8String(ctx->isolate, "decodeBase64"),
+        decodeBase64Fun);
+
+    Handle<Function> dateToArrayFun =
+        compileFunction(DATE_FUNCTION_STRING);
+    context->Global()->Set(createUtf8String(ctx->isolate, "dateToArray"),
+                           dateToArrayFun);
+
+
     // Use EscapableHandleScope and return using .Escape
     // This will ensure that return values are not garbage collected
     // as soon as the function returns.
@@ -642,7 +711,7 @@ void loadFunctions(map_reduce_ctx_t *ctx,
     if(optimize_doc_load) {
         // If esprima compilation fails restore back to pulling in documents.
         try {
-            compileFunction("is_doc_unused");
+            compileFunction((char *)jsFunction_src);
             isDocUsed = false;
         } catch(...) {
             isDocUsed = true;
diff --git a/src/mapreduce/mapreduce.h b/src/mapreduce/mapreduce.h
index 33ed0a0..43178ee 100644
--- a/src/mapreduce/mapreduce.h
+++ b/src/mapreduce/mapreduce.h
@@ -26,7 +26,7 @@
 #include <list>
 #include <vector>
 #include <atomic>
-#include <include/v8.h>
+#include <v8.h>
 #include <platform/platform.h>
 
 #include "erl_nif_compat.h"
@@ -70,26 +70,9 @@ typedef std::basic_string< char,
 typedef std::list< function_source_t,
                    NifStlAllocator< function_source_t > >  function_sources_list_t;
 
-class ArrayBufferAllocator : public v8::ArrayBuffer::Allocator {
-public:
-    virtual void* Allocate(size_t length) {
-        void* data = AllocateUninitialized(length);
-        return data == NULL ? data : memset(data, 0, length);
-    }
-
-    virtual void* AllocateUninitialized(size_t length) {
-        return malloc(length);
-    }
-
-    virtual void Free(void* data, size_t) {
-        free(data);
-    }
-};
-
 typedef struct {
     v8::Persistent<v8::Context>                  jsContext;
     v8::Isolate                                  *isolate;
-    ArrayBufferAllocator                         *bufAllocator;
     function_vector_t                            *functions;
     kv_pair_list_t                               *kvs;
     ErlNifEnv                                    *env;
